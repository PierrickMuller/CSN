\section{Analyse et conception}

\subsection*{Partie 1 :}
La première chose à faire dans ce laboratoire était de mettre en place un plan d'adressage permettant de faciliter le décodage des adresses dans notre interface. On nous fournissait une zone dans le plan d'adressage du DM3730 allant de l'adresse 0x1900\_0000 à 0x193F\_FFFF. Mon choix c'est porté sur le plan ci-dessous pour la zone donnée:\\
\begin{center}
\begin{tabular}{|c|l|l|}
\hline
\textbf{Adresse hex} & \textbf{Lecture(RD actif)} & \textbf{Écriture(WR actif)} \\
			& 15    ...      0  & 15     ...      0  \\
\hline
\hline 
\hline
0x1900\_0000 & [15...0]\textbf{const} & non utilisé\\
\hline
0x1900\_0002 & [15...8] \textbf{'0'} & non utilisé\\
			 & [7...0] \textbf{buttons} & \\
\hline
0x1900\_0004 & non utilisé & [15...8] \textbf{'0'}\\
			 &             & [7...0] \textbf{leds} \\
\hline
0x1900\_0006 & non utilisé & [15...8] \textbf{'0'}\\
			 &             & [7...0] \textbf{aff7seg} \\
\hline
. & & \\
.& libre & libre\\
. & &\\
0x193F\_FFFF & &\\ 
\hline
\end{tabular}
\end{center}
\par
Ce plan d'adressage permet une certaine souplesse dans l'ajout de nouvelles entrée/sorties et permet un décodage des adresses plus aisé dans l'implémentation de l'interface.\\
Voici ci-dessous le schéma produit de l'interface : \\
\begin{center}
\rotatebox{-90}{
\includegraphics[scale=0.55]{./images/partie1_schema.jpg}
}\\\par
\captionof{figure}{Schéma de l'interface partie 1}
\end{center}\par
Les equations qui accompagnent ce schéma sont les suivantes:\\\\
$cs\_rd\_const => cs\_rd \:AND\: (A == 0x000000)$\\
$cs\_rd\_switch => cs\_rd \:AND\: (A == 0x000001)$\\
$cs\_wr\_leds => cs\_wr \: AND\: wr\_en \:AND\: (A == 0x000002)$\\
$cs\_wr\_aff7seg => cs\_wr \: AND\: wr\_en \:AND\: (A == 0x000003)$\\
L'implémentation dans logisim se basera donc sur ce schéma et ces équations.

\subsection*{Partie 2 :}
Dans la deuxième partie, on nous demandais d'expliquer les fonctions des signaux rd\_en\_i et wr\_en\_i. Voici les réponses que j'ai trouvé en analysant le timing du local bus reptar:\\
\begin{itemize}
\item rd\_en\_i sert à s'assurer que les données chargés soit bien les bonnes. En effet, le chip select qui active le multiplexeur et le bus de sélection des entrées permettent de choisir quelles données lire, et rd\_en\_i s'active après pendant un coups de clock afin de charger ces données dans le registre de lecture. Cela répond aussi à une autre question qui nous était posé, sur l'utilité du registre et sur pourquoi le signal rd\_en (rd\_en\_i) est connecté sur ce registre. C'est donc pour assurer la validité des données que l'on souhaite lire, et cela indépendamment des possibles aléas qui pourraient survenir si on utilisait juste le chip select. Ce registre permet aussi de garder en mémoire l'état des sorties lors de la lecture.
\item wr\_en\_i permet de préciser que l'on souhaite effectuer une écriture sur une sortie, en complément de cs\_wr\_i. Cela nous permet d'être bien sure (en plus du décodage de l'adresse) que c'est l'une des sortie de notre interface que l'on souhaite modifier.\\
\end{itemize}\par
On devait par la suite ajouter la possibilité de relire les leds et réaliser la détection du bouton SW5 de manière matérielle. Cela implique quelques modifications dans notre plan d'adressage : \\
\begin{center}
\begin{tabular}{|c|l|l|}
\hline
\textbf{Adresse hex} & \textbf{Lecture(RD actif)} & \textbf{Écriture(WR actif)} \\
			& 15    ...      0  & 15     ...      0  \\
\hline
\hline 
\hline
0x1900\_0000 & [15...0]\textbf{const} & non utilisé\\
\hline
0x1900\_0002 & [15...8] \textbf{'0'} & non utilisé\\
			 & [7...0] \textbf{buttons} & \\
\hline
0x1900\_0004 & [15...8] \textbf{'0'} & [15...8] \textbf{'0'}\\
			 & [7...0] \textbf{leds} & [7...0] \textbf{leds} \\
\hline
0x1900\_0006 & non utilisé & [15...8] \textbf{'0'}\\
			 &             & [7...0] \textbf{aff7seg} \\
\hline
0x1900\_0008 & [15...1] \textbf{'0'} & [15...1] \textbf{'0'}\\
			 & [0] \textbf{detecSW5} & [0] \textbf{acquitSW5} \\
\hline
. & & \\
.& libre & libre\\
. & &\\
0x193F\_FFFF & &\\ 
\hline
\end{tabular}
\end{center}\par
Le point principal ci-dessus vient de l'apparition d'une nouvelle adresse utilisé, 0x1900\_0008 qui permettra en lecture de savoir si SW5 à été appuyer et en écriture d'acquitter cette information (remettre le flag interne à 0).\\\par
La séquence des actions depuis le CPU-REPTAR pour gérer la détection de l'activation de SW5 est la suivante :
\begin{center}
\includegraphics[scale=0.1]{./images/partie2_Chronogramme.jpg}\\\par
\captionof{figure}{Chronogramme des séquences du CPU}
\end{center}\par
\par
La partie 1 concerne l'activation du flag lors de l'activation de SW5. La partie 2 elle représente une lecture de ce flag, qui est comme une lecture d'une entrée normale. Enfin, la partie 3 représente l'acquittement du flag , comme on peut le voir sur le chronogramme avec le passage du flag de 1 à 0. POur cette partie, il n'est pas important de connaitre la valeur écrite dans le flag, étant donnée qu'elle n'y sera pas vraiment écrite, le write servant de commande permettant d'acquitter le flag\\\par
Voici les modifications apportés au schéma de notre interface:
\begin{center}
\rotatebox{-90}{
\includegraphics[scale=0.55]{./images/partie2_schema.jpg}
}\\\par
\captionof{figure}{Schéma de l'interface partie 2}
\end{center}\par
\par
Et voici la machine d'état accompagnant ce schéma : \\
\begin{center}
\includegraphics[scale=0.1]{./images/partie2_MSS.jpg}\\\par
\captionof{figure}{MSS gestion SW5}
\end{center}\par
\par
De plus, trois équations ont été ajoutée à celle de base, soit \\
$cs\_rd\_leds => cs\_rd \: AND\:(A == 0x000002)$\\
$cs\_rd\_flag => cs\_rd \: AND \: (A == 0x000004)$\\
$cs\_wr\_flag => cs\_wr \: AND\: wr\_en \:AND\: (A == 0x000004)$\\
L'implémentation se base sur ces équations et schémas.